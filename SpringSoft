
--!strict

local Spring = {}
Spring.__index = Spring

export type SpringClock = () -> number

function Spring.new<T>(initial: T?, clock: SpringClock?)
	local p0 = initial or 0
	local springClock = clock or os.clock
	local seed = math.random()
	local asym = (seed - 0.5) * 0.12

	return setmetatable({
		_clock = springClock,
		_time0 = springClock(),
		_position0 = p0,
		_velocity0 = 0 * (p0 :: any),
		_target = p0,
		_damper = 0.18 + asym * 0.1,
		_speed = 5.0 + asym,
		_asym = asym,
	} :: any, Spring)
end

function Spring.Impulse<T>(self, velocity: T)
	self.Velocity = (self.Velocity :: any) + velocity
end

(Spring :: any).__index = function(self, index)
	if Spring[index] then return Spring[index] end
	if index == "Position" or index == "p" then
		return self:_positionVelocity(self._clock())
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Velocity" or index == "v" then
		local _, v = self:_positionVelocity(self._clock())
		return v
	elseif index == "Damper" then
		return self._damper
	elseif index == "Speed" then
		return self._speed
	end
	error(string.format("%q is not a valid member of Spring", tostring(index)), 2)
end

function Spring.__newindex(self, index, value)
	local now = self._clock()
	local p, v = self:_positionVelocity(now)

	if index == "Target" then
		self._position0 = p
		self._velocity0 = v
		self._target = value
	elseif index == "Damper" then
		self._position0 = p
		self._velocity0 = v
		self._damper = value
	elseif index == "Speed" then
		self._position0 = p
		self._velocity0 = v
		self._speed = math.max(0, value)
	end

	self._time0 = now
end

function Spring._positionVelocity(self, now)
	local p0 = self._position0
	local v0 = self._velocity0
	local p1 = self._target

	local d = self._damper
	local s = self._speed
	local dt = math.clamp(now - self._time0, 0, 1/30)

	local k = s * s
	local c = 2 * d * s
	local x = p0 - p1
	local a = (-k * x) - (c * v0)

	local v = v0 + a * dt
	local p = p0 + v * dt
	return p, v
end

return Spring
