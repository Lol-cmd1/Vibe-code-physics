--!strict
-- Jello Spring (Soft, Gooey, Wobbly)

local Spring = {}
Spring.__index = Spring

export type SpringClock = () -> number

export type Spring<T> = typeof(setmetatable(
	{} :: {
		Position: T,
		Value: T,
		Velocity: T,
		Target: T,
		Damper: number,
		Speed: number,
		Clock: SpringClock,

		_position0: T,
		_velocity0: T,
		_time0: number,
		_target: T,
		_damper: number,
		_speed: number,
		_clock: SpringClock,
	},
	Spring
))

-- ==============================
-- Constructor
-- ==============================
function Spring.new<T>(initial: T?, clock: SpringClock?): Spring<T>
	local p0 = initial or 0
	local springClock = clock or os.clock

	return setmetatable({
		_clock = springClock,
		_time0 = springClock(),
		_position0 = p0,
		_velocity0 = 0 * (p0 :: any),
		_target = p0,

		-- ðŸ«§ JELLO DEFAULTS
		_damper = 0.15,
		_speed = 0.3,
	}, Spring) :: Spring<T>
end

-- ==============================
-- Preset
-- ==============================
function Spring.Jello<T>(self: Spring<T>)
	self.Damper = 0.12
	self.Speed = 0.25
end

-- ==============================
-- Impulse
-- ==============================
function Spring.Impulse<T>(self: Spring<T>, velocity: T)
	self.Velocity = (self.Velocity :: any) + velocity
end

-- ==============================
-- Indexing
-- ==============================
(Spring :: any).__index = function<T>(self: Spring<T>, index: any): any
	if Spring[index] then
		return Spring[index]
	elseif index == "Position" or index == "Value" or index == "p" then
		local p, _ = self:_positionVelocity(self._clock())
		return p
	elseif index == "Velocity" or index == "v" then
		local _, v = self:_positionVelocity(self._clock())
		return v
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Damper" or index == "d" then
		return self._damper
	elseif index == "Speed" or index == "s" then
		return self._speed
	elseif index == "Clock" then
		return self._clock
	end
	error(string.format("%q is not a valid member of Spring", tostring(index)), 2)
end

function Spring.__newindex<T>(self: Spring<T>, index, value)
	local now = self._clock()
	local p, v = self:_positionVelocity(now)

	if index == "Position" or index == "Value" or index == "p" then
		self._position0 = value
		self._velocity0 = v
	elseif index == "Velocity" or index == "v" then
		self._position0 = p
		self._velocity0 = value
	elseif index == "Target" or index == "t" then
		self._position0 = p
		self._velocity0 = v
		self._target = value
	elseif index == "Damper" or index == "d" then
		self._position0 = p
		self._velocity0 = v
		self._damper = value
	elseif index == "Speed" or index == "s" then
		self._position0 = p
		self._velocity0 = v
		self._speed = math.max(0, value)
	elseif index == "Clock" then
		self._position0 = p
		self._velocity0 = v
		self._clock = value
	end

	self._time0 = now
end

-- ==============================
-- JELLO SPRING MATH
-- ==============================
function Spring._positionVelocity<T>(self: Spring<T>, now: number): (T, T)
	local p0 = self._position0
	local v0 = self._velocity0
	local p1 = self._target
	local d = self._damper
	local s = self._speed

	local t = s * (now - self._time0)
	local d2 = d * d

	local h, si, co
	if d2 < 1 then
		h = math.sqrt(1 - d2)
		local ep = math.exp(-d * t) / h
		co = ep * math.cos(h * t)
		si = ep * math.sin(h * t)
	else
		h = 1
		local ep = math.exp(-d * t)
		co = ep
		si = ep * t
	end

	-- ðŸ«§ Gooey exaggeration
	local a0: any = h * co + d * si
	local a1: any = 1 - a0
	local a2: any = si / (s * 0.6) -- inertia boost

	local b0: any = -s * si
	local b1: any = s * si
	local b2: any = (h * co - d * si) * 0.9 -- soft decay

	return
		a0 * p0 + a1 * p1 + a2 * v0,
		b0 * p0 + b1 * p1 + b2 * v0
end

return Spring
